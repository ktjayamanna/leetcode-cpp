# Big-O Basics
# Introduction to time and space complexity analysis

"""
PROBLEM DESCRIPTION:
================================================================================
This lesson covers the fundamentals of Big-O notation and complexity analysis.

Big-O notation describes the upper bound of the growth rate of an algorithm's
time or space requirements as the input size approaches infinity.

Common Big-O complexities (from best to worst):
- O(1) - Constant time
- O(log n) - Logarithmic time
- O(n) - Linear time
- O(n log n) - Linearithmic time
- O(n²) - Quadratic time
- O(2^n) - Exponential time
- O(n!) - Factorial time


EXAMPLES:
================================================================================
O(1) - Accessing array element by index
O(log n) - Binary search in sorted array
O(n) - Linear search through array
O(n log n) - Efficient sorting algorithms (merge sort, heap sort)
O(n²) - Nested loops over array
O(2^n) - Recursive fibonacci without memoization
O(n!) - Generating all permutations


CONSTRAINTS:
================================================================================
Key principles:
- Focus on worst-case scenario
- Drop constants and lower-order terms
- Consider both time and space complexity
- Analyze as input size grows to infinity

"""

# SOLUTION:
# ================================================================================
# [Add your Python solution here]
